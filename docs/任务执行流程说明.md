# 任务执行流程说明

本文档详细说明了系统中队列任务的执行流程。

## 1. 任务提交

用户通过Web界面提交转录任务，这些任务会被发送到后端的`/transcribe`接口。在`start_transcription`函数中，系统会将任务数据封装成Task对象，并通过`optimized_whisper_system.submit_task()`方法提交到智能队列管理器(`IntelligentQueueManager`)中。

## 2. 任务入队

智能队列管理器(`IntelligentQueueManager`)会根据任务指定的模型类型将任务分组，并存储在不同的队列中，等待调度器来处理。这样可以确保相同模型的任务被统一管理。

## 3. 调度器监控

批处理调度器(`BatchTaskScheduler`)在后台持续运行一个调度循环，定期检查系统中GPU的状态以及各个任务队列中的情况，为下一步的任务分配做准备。

## 4. 任务分配

当调度器检测到某个GPU有足够可用显存来处理更多任务时，它会从等待队列中选取适当的任务。选取过程会考虑任务的模型类型和优先级，以构建一个最优的任务批次。

## 5. 任务执行

构建好的任务批次会被分配给相应的GPU进行处理。实际的执行通过`_process_model_tasks`方法在单独的线程中进行，而具体的转录处理工作则由`_process_single_task`函数完成。

## 6. 进度更新

在任务执行的过程中，系统会通过WebSocket连接将实时进度推送给前端界面，让用户能够看到任务的执行状态。

## 7. 结果处理

当任务完成后，系统会保存转录结果，并将任务状态更新为"完成"或"失败"。这一状态变更同样会通过WebSocket通知前端，以便用户了解最终结果。

## 8. 任务开始运行的判断逻辑

BatchTaskScheduler通过以下步骤判断任务是否开始运行：

1. **调度器监控**：BatchTaskScheduler在后台运行一个调度循环，定期检查GPU状态和各队列中的任务。

2. **任务分配**：当调度器检测到GPU有足够可用显存时，会从队列中选取等待中的任务，根据模型类型和优先级构建最优任务批次。

3. **状态变更**：在`_execute_batch_tasks`方法中，调度器会将选中的任务从"等待中"状态移动到"处理中"状态，这是通过调用`self.queue_manager.move_task_to_processing(task)`实现的。

4. **任务执行**：一旦任务状态变更为"处理中"，调度器就会在单独的线程中执行任务处理函数`_process_model_tasks`，这标志着任务真正开始运行。

5. **进度更新**：在任务处理过程中，系统会定期更新任务进度，并通过WebSocket将进度信息推送到前端。

整个流程通过任务队列管理、智能调度和批量处理机制，确保了系统资源（特别是GPU）得到高效利用。